---
title: 冗余连接
date: 2024-10-27 13:22:54
updated: 2024-10-27 13:22:54
tags:
- 图
- 深度遍历
description: 每天一道算法题，让生活变得更好
categories: 
  - 学习 
  - 代码
  - 算法
---

#### 冗余连接

树可以看成是一个连通且 **无环** 的 **无向** 图。

给定往一棵 `n` 个节点 (节点值 `1～n`) 的树中添加一条边后的图。添加的边的两个顶点包含在 `1` 到 `n` 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 `n` 的二维数组 `edges` ，`edges[i] = [ai, bi]` 表示图中在 `ai` 和 `bi` 之间存在一条边。

请找出一条可以删去的边，删除后可使得剩余部分是一个有着 `n` 个节点的树。如果有多个答案，则返回数组 `edges` 中最后出现的那个。

#### 解答

```python
from collections import defaultdict
from typing import List


class Solution:
    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        graph_map = defaultdict(list)
        for (start, end) in edges:
            graph_map[start].append(end)
            graph_map[end].append(start)

        for i in range(n-1, -1, -1):
            if self.is_linked(n, graph_map, edges[i]):
                return edges[i]

    def is_linked(self, length, graph, remove_item) -> bool:
        traveled = {}

        def inner(node, parent):
            for neighbor in graph[node]:
                if [neighbor, node] == remove_item or [node, neighbor] == remove_item:
                    continue
                if neighbor == parent or neighbor in traveled:
                    continue
                traveled[neighbor] = True
                inner(neighbor, node)

        traveled[1] = True
        inner(1, -1)

        return len(traveled) == length
```

#### 思路

从题干中推测出是使用图算法的。

直接暴力推断，先构成图，然后从右到左遍历数组，判读结果是否还可以连接成图，保证每个节点都可以访问到即可。每个节点可以访问到的判断依据，从任意一个节点开始，都可以访问 从 **1-N**的节点，我选择了从1开始。

#### 复杂度

时间复杂度：O(N ^ 2)

空间复杂度：O(N)
