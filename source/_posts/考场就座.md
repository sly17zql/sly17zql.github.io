---
title: 【每日算法题】考场就座
date: 2024-12-23 10:26:47
updated: 2024-12-23 10:26:47
tags:
  - 优先级队列
  - hashmap
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
---

### 考场就座

在考场里，有 n 个座位排成一行，编号为 0 到 n - 1。

当学生进入考场后，他必须坐在离最近的人最远的座位上。如果有多个这样的座位，他会坐在编号最小的座位上。(另外，如果考场里没有人，那么学生就坐在 0 号座位上。)

设计一个模拟所述考场的类。

实现 ExamRoom 类：

ExamRoom(int n) 用座位的数量 n 初始化考场对象。
int seat() 返回下一个学生将会入座的座位编号。
void leave(int p) 指定坐在座位 p 的学生将离开教室。保证座位 p 上会有一位学生。

### 解答

```python
class ExamRoom:
    def __init__(self, n: int):
        self.n = n
        from sortedcontainers import SortedSet

        def define_sort(node):
            if node[0] == -1:
                return node[1] - 0
            elif node[1] == self.n:
                return node[1] - 1 - node[0]
            else:
                return (node[1] - node[0]) // 2

        self.stack = SortedSet(key=lambda x: (-define_sort(x), x[0]))
        self.left = {}
        self.right = {}
        self.add(-1, self.n)

    def seat(self) -> int:
        cur_node = self.stack[0]
        start, end = cur_node
        if start == -1:
            new_node = 0
        elif end == self.n:
            new_node = self.n - 1
        else:
            new_node = (start + end) // 2
        self.remove(start, end)
        self.add(start, new_node)
        self.add(new_node, end)
        return new_node

    def leave(self, p: int) -> None:
        left = self.left[p]
        right = self.right[p]
        self.remove(left, p)
        self.remove(p, right)
        self.add(left, right)

    def add(self, l, r):
        self.left[r] = l
        self.right[l] = r
        self.stack.add((l, r))

    def remove(self, l, r):
        self.left.pop(r)
        self.right.pop(l)
        self.stack.remove((l, r))
```

### 思路

我们先进行分类讨论：

1、如果当前没有人，直接返回0位；

2、如果当前1个人，则在0和n-1位选择一个；

3、其他情况则使用优先级队列获取间隔最大的位置。

如何设计优先级队列，则需要排序 左侧 和 右侧两端，对二取整除，获取到间隔。
为了保证有人走掉之后，可以删除掉数值，需要维护两个hashmap，维护左侧和右侧的值。

### 复杂度

时间复杂度：O(nlogn)

空间复杂度：O(n)
