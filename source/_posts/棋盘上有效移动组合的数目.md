---
title: 【每日算法题】棋盘上有效移动组合的数目
tags:
  - 回溯
  - 递归
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 2795
date: 2024-12-04 09:51:54
updated: 2024-12-04 09:51:54
---

### 棋盘上有效移动组合的数目

有一个 8 x 8 的棋盘，它包含 n 个棋子（棋子包括车，后和象三种）。给你一个长度为 n 的字符串数组 pieces ，其中 pieces[i] 表示第 i 个棋子的类型（车，后或象）。除此以外，还给你一个长度为 n 的二维整数数组 positions ，其中 positions[i] = [ri, ci] 表示第 i 个棋子现在在棋盘上的位置为 (ri, ci) ，棋盘下标从 1 开始。

每个棋子的移动中，首先选择移动的 方向 ，然后选择 移动的步数 ，同时你要确保移动过程中棋子不能移到棋盘以外的地方。棋子需按照以下规则移动：

车可以 水平或者竖直 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1) 或者 (r, c-1) 移动。
后可以 水平竖直或者斜对角 从 (r, c) 沿着方向 (r+1, c)，(r-1, c)，(r, c+1)，(r, c-1)，(r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
象可以 斜对角 从 (r, c) 沿着方向 (r+1, c+1)，(r+1, c-1)，(r-1, c+1)，(r-1, c-1) 移动。
你必须同时 移动 棋盘上的每一个棋子。移动组合 包含所有棋子的 移动 。每一秒，每个棋子都沿着它们选择的方向往前移动 一步 ，直到它们到达目标位置。所有棋子从时刻 0 开始移动。如果在某个时刻，两个或者更多棋子占据了同一个格子，那么这个移动组合 不有效 。

请你返回 有效 移动组合的数目。

注意：

初始时，不会有两个棋子 在 同一个位置 。
有可能在一个移动组合中，有棋子不移动。
如果两个棋子 直接相邻 且两个棋子下一秒要互相占据对方的位置，可以将它们在同一秒内 交换位置 。

### 解答

```python
class Solution:
    def countCombinations(self, pieces: List[str], positions: List[List[int]]) -> int:
        """
        rook: 车，垂直
        queen：皇后，垂直+斜
        bishop：象，斜
        """
        direction_map = {
            "rook": [(0, 1), (1, 0), (0, -1), (-1, 0)],
            "queen": [(0, -1), (1, 0), (0, 1), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)],
            "bishop": [(1, 1), (1, -1), (-1, 1), (-1, -1)],
        }
        n = len(pieces)

        def check_validated(d, p, m):
            pos = []
            for i in range(n):
                if not m[i]:
                    new_p = p[i]
                else:
                    dx, dy = d[i]
                    new_x, new_y = p[i][0] + dx, p[i][1] + dy
                    if new_x < 1 or new_x > 8 or new_y < 1 or new_y > 8:
                        return
                    new_p = [new_x, new_y]
                if new_p in pos:
                    return
                pos.append(new_p)
            return pos

        def inner(directions, positions, move_flag):
            if not any(move_flag):
                return
            new_positions = check_validated(directions, positions, move_flag)
            if new_positions is None:
                return

            nonlocal ans
            ans += 1

            choices = [[1, 0] if flag else [0] for flag in move_flag]

            for move in product(*choices):
                inner(directions, new_positions, move)

        choices = list(product(*[[1, 0] for _ in range(len(pieces))]))
        ans = 1  # 初始化算一個
        for c in choices:
            choice = list(c)
            for direction in product(*[direction_map.get(p) if choice[index] else [(0, 0)] for index, p in enumerate(pieces)]):
                inner(direction, positions, c)
        return ans
```

### 思路

先记录每个棋子可能的运动方向，且每个棋子可以有动或者不动的可能性。注意：如果 queen选择了方向1且不动，那么和queen选择了方向2且不动，那么其实效果是一样的，需要剔除这种情况，否则会重复计算。

在选好方向和是否运动后，在每次进入前，需要判断是否合法，1、是否出界，2、是否有棋子重叠。不合法时，直接返回；合法，则答案+1，并且继续计算。

最后一个注意点，起始位置，所有棋子都不动也是一个答案，最后答案+1。

### 复杂度

棋子数量：n，棋子的运动方向：m

时间复杂度：O(n*m^n)

空间复杂度：O(n*m)
