---
title: 【每日算法题】大礼包
date: 2024-11-03 20:24:19
tags:
  - 递归
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
---

### 大礼包

在 LeetCode 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。

给你一个整数数组 price 表示物品价格，其中 price[i] 是第 i 件物品的价格。另有一个整数数组 needs 表示购物清单，其中 needs[i] 是需要购买第 i 件物品的数量。

还有一个数组 special 表示大礼包，special[i] 的长度为 n + 1 ，其中 special[i][j] 表示第 i 个大礼包中内含第 j 件物品的数量，且 special[i][n] （也就是数组中的最后一个整数）为第 i 个大礼包的价格。

返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。

### 解答

```python
class Solution:
    def shoppingOffers(self, price: List[int], special: List[List[int]], needs: List[int]) -> int:
        n = len(price)

        def get_sum(needs_list):
            return sum([price[i] * needs_list[i] for i in range(n)])

        def inner(new_needs, cost=0):
            nonlocal ans
            if cost >= ans:
                return
            cur_ans = get_sum(new_needs)
            ans = min(ans, cost + cur_ans)
            for item in special:
                nums = [new_needs[i] - item[i] for i in range(n)]
                if any(num < 0 for num in nums):
                    continue
                inner(nums, cost + item[-1])

        ans = get_sum(needs)
        inner(needs, cost=0)
        return ans
        
```

### 思路

使用递归思想。因为不能超过需要购买的数量，遍历 大礼包，如果数值小于等于当前的 new_needs，那么可以使用这个大礼包，cost + 当前大礼包的cost。并在递归进入时，判断如果当前全部单买的价格。

### 复杂度

时间复杂度：O(n×k×m^n)，其中 k 表示大礼包的数量，m 表示每种物品的需求量的可能情况数（等于最大需求量加 1），n 表示物品数量。我们最多需要处理 m^n 个状态，每个状态需要遍历 k 种大礼包的情况，每个大礼包需要遍历 n 种商品以检查大礼包是否可以购买。

空间复杂度:O(n×m^n)，用于存储记忆化搜索中 m^n 个状态的计算结果，每个状态需要存储 n 个商品的需求量。
