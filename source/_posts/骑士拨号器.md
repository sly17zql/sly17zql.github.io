---
title: 【每日算法题】骑士拨号器
tags:
  - 动态规划
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 11812
date: 2024-12-10 10:14:25
updated: 2024-12-10 10:14:25
---

### 骑士拨号器

象棋骑士有一个独特的移动方式，它可以垂直移动两个方格，水平移动一个方格，或者水平移动两个方格，垂直移动一个方格(两者都形成一个 L 的形状)。

象棋骑士可能的移动方式如下图所示:

{% asset_img chess.png %}

我们有一个象棋骑士和一个电话垫，如下所示，骑士只能站在一个数字单元格上(即蓝色单元格)。

{% asset_img phone.png %}

给定一个整数 n，返回我们可以拨多少个长度为 n 的不同电话号码。

你可以将骑士放置在任何数字单元格上，然后你应该执行 n - 1 次移动来获得长度为 n 的号码。所有的跳跃应该是有效的骑士跳跃。

因为答案可能很大，所以输出答案模 10^9 + 7.

### 解答

```python
class Solution:
    def knightDialer(self, n: int) -> int:
        dir_map = {
            0: [4, 6],
            1: [6, 8],
            2: [7, 9],
            3: [4, 8],
            4: [0, 3, 9],
            5: [],
            6: [0, 1, 7],
            7: [2, 6],
            8: [1, 3],
            9: [2, 4],
        }
        mod_num = 10 ** 9 +7

        ret = [
            [0 for _ in range(10)]
            for _ in range(n)
        ]
        for num in range(10):
            ret[0][num] = 1

        for i in range(1, n):
            for num in range(10):
                for pre in dir_map[num]:
                    ret[i][num] += ret[i-1][pre]
                    ret[i][num] %= mod_num
        return sum(ret[-1]) % mod_num
```

### 思路

使用hashmap记录运行的来源地。

转换：

不过需要判断，如果1来源可能是4， 6

f(n, 1) = f(n-1, 4) + f(n-1, 6)

### 复杂度

时间复杂度：O(N)

空间复杂度：O(N)
