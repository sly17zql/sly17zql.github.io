---
title: 【每日算法题】变为棋盘
tags:
  - 位运算
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 43862
date: 2024-12-08 19:41:29
updated: 2024-12-08 19:41:29
---

### 变为棋盘

一个 n x n 的二维网络 board 仅由 0 和 1 组成 。每次移动，你能交换任意两列或是两行的位置。

返回 将这个矩阵变为  “棋盘”  所需的最小移动次数 。如果不存在可行的变换，输出 -1。

“棋盘” 是指任意一格的上下左右四个方向的值均与本身不同的矩阵。

### 解答

```python
class Solution:
    def movesToChessboard(self, board: List[List[int]]) -> int:
        first_row = board[0]
        row_c = Counter(first_row)
        if abs(row_c.get(0, 0) - row_c.get(1, 0)) > 1:
            return -1

        first_col = [board[i][0] for i in range(len(board))]
        col_c = Counter(first_col)
        if abs(col_c.get(0, 0) - col_c.get(1, 0)) > 1:
            return -1

        for i in range(1, len(board)):
            same = board[i][0] == first_row[0]
            for x, y in zip(board[i], first_row):
                if (x == y) != same:
                    return -1

        def min_swap(arr: List[int], cnt: Counter) -> int:
            n = len(arr)
            if n % 2 == 1:
                if cnt.get(1) > cnt.get(0):
                    diff = sum((i % 2) ^ x ^ 1 for i, x in enumerate(arr))
                else:
                    diff = sum((i % 2) ^ x ^ 0 for i, x in enumerate(arr))
            else:
                diff = min(
                    sum((i % 2) ^ x ^ 1 for i, x in enumerate(arr)),
                    sum((i % 2) ^ x ^ 0 for i, x in enumerate(arr))
                )
            return diff // 2

        return min_swap(first_row, row_c) + min_swap(first_col, col_c)
```

### 思路

逆向思维，棋盘可以转换为怎么样的样子呢。

发现01010101和10101010，不论行怎么换，列怎么换，行和列都只会有两种情况，且互相完全相反。

如果当前的行列只有两种情况，且偶数时数量相同，每行每列1和0的数量一样，奇数时数量差1，每行每列1和0的统计数量差1。

### 复杂度

N 为 棋盘的宽度。

时间复杂度：O(N^2)

空间复杂度：O(N)
