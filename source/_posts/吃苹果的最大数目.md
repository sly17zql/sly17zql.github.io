---
title: 【每日算法题】吃苹果的最大数目
date: 2024-12-24 11:33:23
updated: 2024-12-24 11:33:23
tags:
  - 优先级队列
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
---

### 吃苹果的最大数目

有一棵特殊的苹果树，一连 n 天，每天都可以长出若干个苹果。在第 i 天，树上会长出 apples[i] 个苹果，这些苹果将会在 days[i] 天后（也就是说，第 i + days[i] 天时）腐烂，变得无法食用。也可能有那么几天，树上不会长出新的苹果，此时用 apples[i] == 0 且 days[i] == 0 表示。

你打算每天 最多 吃一个苹果来保证营养均衡。注意，你可以在这 n 天之后继续吃苹果。

给你两个长度为 n 的整数数组 days 和 apples ，返回你可以吃掉的苹果的最大数目。

### 解答

```python
class Solution:
    def eatenApples(self, apples: List[int], days: List[int]) -> int:
        stack = []
        heapq.heapify(stack)
        n = len(apples)
        step = 0
        ans = 0
        while step < n or stack:
            if step < n:
                c = apples[step]
                age = days[step]
                if c > 0:
                    if age == 1:
                        ans += 1
                        step += 1
                        continue
                    else:
                        heapq.heappush(stack, [age + step, c])
            while stack:
                cur_age, num = stack[0]
                if cur_age > step:
                    ans += 1
                    num -= 1
                    if num > 0:
                        heapq.heapreplace(stack, [cur_age, num])
                    else:
                        heapq.heappop(stack)
                    break
                else:
                    heapq.heappop(stack)
            step += 1
        return ans
```

### 思路

贪心的思想，每天吃最早过期的苹果，所以我们需要维护一个优先级队列，记录苹果的过期时间和当前数量。

每过一天，需要从队列中获取到最早过期的苹果信息，如果已经过期，则继续从队列中获取，如果没有过期，则吃一个，记录数量减一，如果仍大于0，则重新添加回队列中。

直到优先级队列为空或者不可能再有新的苹果产生时，退出循环。

### 复杂度

时间复杂度：O(NlogN)

空间复杂度：O(N)



