---
title: 【每日算法题】可以被一步捕获的棋子数
tags:
  - 深度遍历
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 55022
date: 2024-12-06 21:02:34
updated: 2024-12-06 21:02:34
---

### 可以被一步捕获的棋子数

给定一个 8 x 8 的棋盘，只有一个 白色的车，用字符 'R' 表示。棋盘上还可能存在白色的象 'B' 以及黑色的卒 'p'。空方块用字符 '.' 表示。

车可以按水平或竖直方向（上，下，左，右）移动任意个方格直到它遇到另一个棋子或棋盘的边界。如果它能够在一次移动中移动到棋子的方格，则能够 吃掉 棋子。

注意：车不能穿过其它棋子，比如象和卒。这意味着如果有其它棋子挡住了路径，车就不能够吃掉棋子。

返回白车 攻击 范围内 兵的数量。

### 解答

```python
class Solution:
    def numRookCaptures(self, board: List[List[str]]) -> int:
        r = None
        for x in range(len(board)):
            for y in range(len(board[0])):
                if board[x][y] == 'R':
                    r = (x, y)
                    break

        ans = 0
        for (i, j) in [[1, 0], [-1, 0], [0, -1], [0, 1]]:
            cur_x, cur_y = r
            while True:
                new_x, new_y = cur_x + i, cur_y + j
                if new_x < 0 or new_x >= len(board) or new_y < 0 or new_y >= len(board[0]):
                    break
                if board[new_x][new_y] == 'B':
                    break
                if board[new_x][new_y] == 'p':
                    ans += 1
                    break
                cur_x = new_x
                cur_y = new_y
        return ans
```

### 思路

先获取到车的坐标，分别向上下左右深度遍历，如果先遇到对方的卒，答案才加1。

### 复杂度

时间复杂度：O(M)

空间复杂度：O(1)
