---
title: 【每日算法题】二叉树中的链表
tags:
  - 深度遍历
  - 记忆搜索法
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 1002
date: 2024-12-30 21:28:02
updated: 2024-12-30 21:28:02
---

### 二叉树中的链表

给你一棵以 root 为根的二叉树和一个 head 为第一个节点的链表。

如果在二叉树中，存在一条一直向下的路径，且每个点的数值恰好一一对应以 head 为首的链表中每个节点的值，那么请你返回 True ，否则返回 False 。

一直向下的路径的意思是：从树中某个节点开始，一直连续向下的路径。

### 解答

```python
from functools import cache
from typing import Optional

from utils import assert_util


class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next


class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right


class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:
        def dfs1(cur_node: ListNode):
            if cur_node:
                head_list.append(cur_node.val)
                dfs1(cur_node.next)

        head_list = []
        dfs1(head)

        if not head_list:
            return True

        @cache
        def dfs(cur_node: TreeNode, step):
            if cur_node.val == head_list[step]:
                if step == len(head_list) - 1:
                    return True
                if cur_node.left:
                    ret = dfs(cur_node.left, step + 1)
                    if ret:
                        return True
                if cur_node.right:
                    ret = dfs(cur_node.right, step + 1)
                    if ret:
                        return True
            if cur_node.left:
                ret = dfs(cur_node.left, 0)
                if ret:
                    return True
            if cur_node.right:
                ret = dfs(cur_node.right, 0)
                if ret:
                    return True
            return False

        if root:
            return dfs(root, 0)
        return False


if __name__ == '__main__':
    s = Solution()
    """
    head = [4,2,8], root = [1,4,4,null,2,2,null,1,null,6,8,null,null,null,null,1,3]
    """
    ln3 = ListNode(8)
    ln2 = ListNode(2, next=ln3)
    ln1 = ListNode(4, next=ln2)

    tn10 = TreeNode(3)
    tn9 = TreeNode(1)
    tn8 = TreeNode(8, left=tn9, right=tn10)
    tn7 = TreeNode(6)
    tn5 = TreeNode(2, left=tn7, right=tn8)
    tn3 = TreeNode(4, left=tn5)
    tn6 = TreeNode(1)
    tn4 = TreeNode(2, left=tn6)
    tn2 = TreeNode(4, right=tn4)
    tn1 = TreeNode(1, left=tn2, right=tn3)

    assert_util(s.isSubPath, expect=True, head=ln1, root=tn1)
```

### 思路

先深度遍历获取到目标链表的int list。然后递归树结构，需要携带额外标识位，表示当前到了链表的第几位，比较两个值是否相同，
当相同，且step到达最后一位时，则返回True；如果还未到最后一位，则step+1，继续递归。如果发现失败，则尝试使用当前节点的左右儿子作为起始点。

最后使用记忆搜索法进行优化，防止重复计算。

### 复杂度

链表长度：m，树结构深度：n

时间复杂度：O(nm)

空间复杂度：O(m)
