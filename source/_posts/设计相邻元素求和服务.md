---
title: 【每日算法题】设计相邻元素求和服务
date: 2024-11-09 18:23:19
updated: 2024-11-09 18:23:19
tags:
  - hashmap
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
---

### 设计相邻元素求和服务

给你一个 n x n 的二维数组 grid，它包含范围 [0, n2 - 1] 内的不重复元素。

实现 neighborSum 类：

neighborSum(int [][]grid) 初始化对象。

int adjacentSum(int value) 返回在 grid 中与 value 相邻的元素之和，相邻指的是与 value 在上、左、右或下的元素。

int diagonalSum(int value) 返回在 grid 中与 value 对角线相邻的元素之和，对角线相邻指的是与 value 在左上、右上、左下或右下的元素。

### 解答

```python
class NeighborSum:
    def __init__(self, grid: List[List[int]]):
        self.grid = grid
        self.map = {}
        self.build_map()

    def build_map(self):
        n = len(self.grid)
        for x in range(n):
            for y in range(n):
                self.map[self.grid[x][y]] = [x, y]

    def adjacentSum(self, value: int) -> int:
        x, y = self.map[value]
        n = len(self.grid)
        ans = 0
        for item in [[-1, 0], [1, 0], [0, -1], [0, 1]]:
            new_x = x + item[0]
            new_y = y + item[1]
            if 0 <= new_x < n and 0 <= new_y < n:
                ans += self.grid[new_x][new_y]
        return ans

    def diagonalSum(self, value: int) -> int:
        x, y = self.map[value]
        n = len(self.grid)
        ans = 0
        for item in [[-1, -1], [1, 1], [1, -1], [-1, 1]]:
            new_x = x + item[0]
            new_y = y + item[1]
            if 0 <= new_x < n and 0 <= new_y < n:
                ans += self.grid[new_x][new_y]
        return ans

```

### 思路

因为每个元素都是独一无二的，所以使用hashmap来维护整个二维数组，计算周围的数值，则使用计算坐标位置。

### 复杂度

时间复杂度：O(N^2)

空间复杂度：O(N^2)

