---
title: 执行操作可获得的最大总奖励 II
abbrlink: 7933
date: 2024-10-26 13:04:32
updated: 2024-10-26 13:04:32
tags:
  - DP
  - 位运算
categories:
  - 学习
  - 代码
---

#### 执行操作可获得的最大总奖励 II

给你一个整数数组 `rewardValues`，长度为 `n`，代表奖励的值。

最初，你的总奖励 `x` 为 0，所有下标都是 **未标记** 的。你可以执行以下操作 **任意次** ：

- 从区间 `[0, n - 1]` 中选择一个 **未标记** 的下标 `i`。
- 如果 `rewardValues[i]` **大于** 你当前的总奖励 `x`，则将 `rewardValues[i]` 加到 `x` 上（即 `x = x + rewardValues[i]`），并 **标记** 下标 `i`。

以整数形式返回执行最优操作能够获得的 **最大** 总奖励。

#### 解答

```python
class Solution:
    def maxTotalReward(self, rewardValues: List[int]) -> int:
        ret = 1
        rewardValues.sort()

        for item in rewardValues:
            ret |= (((1 << item) - 1) & ret) << item
        return ret.bit_length() - 1
```

#### 思路

基本思路： {% post_link 执行操作可获得的最大总奖励 I %}。由于上一篇文章的思路可以基本套用，基于之前的思路，由于本体的数据量大小提高到了 5 * 10 ^ 4，导致原本的解体方式会超时时间限制，所以再次前提之上做出优化。

优化思路：使用位运算代替，之前的遍历数组，基本思想，就是因为每个值是一个bool值，可以实现为True，无法实现为False。

优化方案具体：

- 由于我们从小到大的遍历思想，当我们遍历到大小 N 的数值时，我们需要判断 0-（N-1）是否有满足条件的答案出现，如果有那么便可以作为答案加入到现有答案序列中。
- 先将 N 转换为 N 位长度的二进制，减一，表示 1 - （N - 1）位。
- 然后与 当前结果 ret 取 按位与，如果当前位为 1 表示可以实现。
- 最后与当前数值求和，那么整体往左移 N，即可得到一个目标值的 新的 ret。

#### 复杂度

rewardValues 长度为N， 最大值位 M

时间复杂度：NM/32 (这个时间复杂度和空间复杂度的表示暂时存惑) 
空间复杂度：M/32

