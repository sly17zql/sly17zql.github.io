---
title: 【每日算法题】统计好节点的数目
tags:
  - 树
  - 图
description: 每天一道算法题，让生活变得更好
categories:
  - 学习
  - 代码
  - 算法
abbrlink: 32731
date: 2024-11-14 19:19:47
updated: 2024-11-14 19:19:47
---

### 统计好节点的数目

现有一棵 无向 树，树中包含 n 个节点，按从 0 到 n - 1 标记。树的根节点是节点 0 。给你一个长度为 n - 1 的二维整数数组 edges，其中 edges[i] = [ai, bi] 表示树中节点 ai 与节点 bi 之间存在一条边。

如果一个节点的所有子节点为根的 子树 包含的节点数相同，则认为该节点是一个 好节点。 返回给定树中 好节点 的数量。

子树 指的是一个节点以及它所有后代节点构成的一棵树。

### 解答

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.children = []
        self.all_children_count = 0


class Solution:
    def countGoodNodes(self, edges: List[List[int]]) -> int:
        edges.sort()
        graph = defaultdict(list)
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)
        
        ans = 0

        def inner(node, parent):
            children_length = None
            flag = True
            for neighbor in graph[node.value]:
                if neighbor in travel_map or neighbor == parent:
                    continue
                node.all_children_count += 1
                neighbor_node = Node(neighbor)
                node.children.append(neighbor_node)
                inner(neighbor_node, node.value)
                node.all_children_count += neighbor_node.all_children_count
                if children_length is None:
                    children_length = neighbor_node.all_children_count
                else:
                    if children_length != neighbor_node.all_children_count:
                        flag = False
            if flag is True:
                nonlocal ans
                ans += 1

        root = Node(0)
        travel_map = {0: True}
        inner(root, -1)

        return ans
```

### 思路

先构图，再构树，深度遍历构树中，计算children的数量

### 复杂度

时间复杂度：O(N)

空间复杂度：O(N)
